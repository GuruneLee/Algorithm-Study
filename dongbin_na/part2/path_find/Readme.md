# 최단 경로 - 가장 빠른 길 찾기
여러가지 상황이 있음
- 한 지점에서 다른 특정 지점까지 최단 경로
- 모든 지점에서 다른 모든 지점까지 최단 경로
  
알고리즘 종류
- 다익스트라 최단 경로 알고리즘
- 플로이드 워셜 
- 벨만 포드

특징
- 그리디 알고리즘 + DP 알고리즘이 적용됨

## 다익스트라 최단 경로 알고리즘 (Dijkstra)
: 한 지점에서 다른 특정 지점까지의 최단경로
- 간선이 모두 0이상
- **그리디**
- 1차원 배열
- 프로세스
    1. 출발노드 설정
    2. '최단 거리 테이블' 초기화
    3. 방문하지 않은 노드 중, 최단 거리가 가장 짧은 노드 선택
    4. 해당 노드를 거쳐갈을 시, 다른 노드로 가는 비용 계산. '최단 거리 테이블' 갱신
    5. `3` `4` 반복
- 시간복잡도
    heap을 이용하면 O(ElogV)

## 플로이드 워셜 알고리즘 (Floyd-Warshall)
: 모든 지점에서 다른 모든 지점까지의 최단경로
- **DP**
- 2차원 배열
- 다익스트라와 비슷하게 '거쳐가는 노드'를 기준으로 알고리즘 수행
- But, 매번 최단 거리를 갖는 노드를 찾을 필요 없음

- 시간 복잡도
    노드 개수가 N개일 때, N번의 단계를 수행하며  
    단계마다 O(N*N)의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려함  
    -> O(N^3)  

- 프로세스
     : 현재 방문 중인 노드를 제외한 N-1개의 노드 중, 서로 다른 노드 (A,B)쌍을 선택하여, 이후에 [A -> 방문중인 노드 -> B]의 비용을 확인해서, 최단 거리를 갱신함  
     - 점화식: `D(a,b) = min(D(a,b), D(a,k)+D(k,b))`

- source code (cpp)
    ~~~cpp
    //Floyd-Warshall
    #define INF 987654321

    int v; //노드 개수
    int e; //간선 개수
    int dp[n+1][n+1] = INF; //인접 행렬꼴의 dp테이블 초기화

    //대각성분 0으로 초기화
    for (int i=1; i<n+1; i++) {
        dp[i][i] = 0;
    }

    //노드와 간선 정보 받아서 dp초기화
    while(m--) {
        cin >> tmpV1 >> tmpV2; //노드 정보
        cin >> tmpE; //해당 노드 사이의 간선 정보
        dp[tmpV1][tmpV2] = tmpE;
    }

    //점화식에 따라 Floyd-Warshall알고리즘 수행
    for (int i=1; i<n+1; i++) { //i번째 노드 방문
        for (int a=1; a<n+1; a++) { 
            for (int b=1; b<n+1; b++) { 
                //a,b 쌍에 대한 점화식
                dp[a][b] = min(dp[a][b], dp[a][i]+dp[i][b]);
            } 
        }
    }
    ~~~