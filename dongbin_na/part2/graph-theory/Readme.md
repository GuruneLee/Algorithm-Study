# 그래프 이론

## 서로소 집합 알고리즘
### 필요성 / 목적 / 이거 배워서 뭐하나? 
find/union연산을 통해 
1. 사이클 존재 여부 판별
2. 신장트리 만들기 (크루스칼 알고리즘)
3. 위상 정렬 알고리즘 (방향그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것)

### 서로소 집합 자료구조
: 서로소 부분 집합들로 나누어진 원소들의 데이터 처리를 위한 자료구조
- **union-find자료구조** 라고도 불림
    - union: 두 개의 원소가 포함된 집합을 하나로 합치기
    - find: 특정 원소를 포함하는 집합 찾기
- **Tree**를 이용한 집합 표현
    - union
        1. 서로 연결된 두 노드 a,b를 확인
            - a,b의 루트 노드 A,B를 각각 찾는다
            - A를 B의 부모노드로 설정한다 (작은원소가 부모노드가 되게 한다)
        2. 모든 union연산을 처리할 때 까지, `1`반복
    - 부모 테이블
        - 부모테이블을 갱신해서, 속한 집합을 찾을 수 있게 됨
        - 해당 노드의 루트노드가 바로 속한 집합을 대표하는 원소가 됨
        1. 노드의 개수를 사이즈로 하는 1차원 테이블 초기화
            - 처음엔 자기 자신이 부모노드
                | 노드번호 | 1 | 2 | 3 | 4 | 5 |
                |:---:|:---:|:---:|:---:|:---:|:---:|
                | 부모노드 | 1 | 2 | 3 | 4 | 5 |
        2. union연산을 할 때 마다, 부모노드 갱신
            - 루트 노드를 확인할때는 재귀적인 프로세스 필요 (부모노드만 확인할 수 있기때문)
            - union 1,4
                1. 1,4의 루트노드는 1,4
                2. 1<4 이므로 4의 부모노드를 1로 변경
                    | 노드번호 | 1 | 2 | 3 | 4 | 5 | 6 |
                    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
                    | 부모노드 | 1 | 2 | 3 | 1 | 5 | 6 |
            - union 2,3
                1. 2,3의 루트노드는 2,3
                2. 2<3 이므로 3의 부모노드를 2로 변경
                    | 노드번호 | 1 | 2 | 3 | 4 | 5 | 6 |
                    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
                    | 부모노드 | 1 | 2 | 2 | 1 | 5 | 6 |
            - union 2,4
                1. 2,4의 루트노드는 2,1
                2. 1<2 이므로 2의 부모노드를 1로 변경
                    | 노드번호 | 1 | 2 | 3 | 4 | 5 | 6 |
                    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
                    | 부모노드 | 1 | 1 | 2 | 1 | 5 | 6 |
            - union 5,6
                1. 5,6의 루트노드는 5,6
                2. 5<6 이므로 6의 부모노드를 5로 변경
                    | 노드번호 | 1 | 2 | 3 | 4 | 5 | 6 |
                    |:---:|:---:|:---:|:---:|:---:|:---:|:---:|
                    | 부모노드 | 1 | 1 | 2 | 1 | 5 | 5 |
        3. 재귀적 호출을 통해 루트 노드를 찾아내면, 해당 루트노드가 해당 집합의 대표 원소가 됨.
    - 이를 Tree구조로 나타낸다면  
        <img src=./union-tree.PNG>
        1. 트리의 노드 = 각 원소
        2. 트리의 간선 = 같은 집합에 속함을 나타내는 union연산
        3. 각 트리의 루트노드 = 해당 집합의 대표 원소

### source code - find/union
~~~cpp
//특정 원소가 속한 집합 찾기 (find)
int find_parent(int x) {
    if (parent[x] != x) {
        //부모노드가 루트노드가 아니라면, 루트노드를 찾을 때까지 재귀적 호출
        return find_parent(parent[x]); 
    }
    return x;
}

//두 원소가 속한 집합을 합치기 (union)
void uion_parent(int a, int b) {
    int A = find_parent(a);
    int B = find_parent(b);
    if (A<B) {
        parent[b] = A;
    } else {
        parent[a] = B;
    }
}
~~~

- 비효율적으로 작동하는 find_parent함수를 개선해보자
- **경로 압축**을 사용할 거임
    : 루트 노드를 찾으면, 부모테이블의 부모를 루트노드로 갱신해버림
    ~~~cpp
    //경로 압축을 통해 특정 원소가 속한 집합 찾기 (find)
    int find_parent(int x) {
        if (parent[x] != x) {
            //부모노드가 루트노드가 아니라면, 루트노드를 찾을 때까지 재귀적 호출
            //찾으면 바로바로 갱신해벌이기
            parent[x] = find_parent(parent[x]); 
        }
        return parent[x];
    }
    ~~~

## 서로소 집합을 활용한 사이클 판별
- undirected그래프에서 사이클 판별을 위해 사용가능
- directed에서는 DFS를 이용해야함 (다음 기회에)
- 프로세스
    : 그래프의 각 간선을 확인하며, 두 노드의 루트노드가 다르다면 union연산을 수행 (부모테이블 갱신) / 만약 루트 노드가 같다면 사이클(cycle)이 발생한 것  
    -> 그래프의 모든 간선에 대하여 반복
- source code
    ~~~cpp
    // 노드와 간선의 개수
    int V,E;
    // 부모테이블 초기화 (부모 = 자기자신)
    int parent[] = {1,2,3,...,V};
    
    //판별 함수
    bool isCycle(int[] parent) {
        // 그래프의 간선 a,b
        for (int i=0; i<E; i++) {
            int a = i;
            for (auto e : graph[a]) {
                int b = e;
                //a,b의 루트 노드가 같으면 cycle이 존재하는 것
                if (find_parent(a) == find_parent(b)) {
                    return true;
                //같지 않다면 union연산 수행
                } else {
                    union_parent(a,b);
                }
            } 
        }
        return false;
    }
    ~~~

## 신장트리 추출
- 신장트리
    : 무방향 그래프가 있을 때, **모든 노드를 포함**하면서 **사이클이 존재하지 않는 부분 그래프**
### 크루스칼 알고리즘 (Kruskal Algorithm)
: **최소 신장 트리**를 만드는 방법.
- 시간 복잡도
    - O(ElogE)
- 프로세스
    1. 간선 데이터를 비용에 따라 오름차순으로 정렬
    2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
        - 사이클 발생 -> 신장 트리에 포함시키지 않음
        - 사이클 발생x -> 신장 트리에 포함시킴
    3. 모든 간선에 대해 `2`를 반복
- source code
    ~~~cpp
    // 노드와 간선의 개수
    int V,E;
    vector<int cost, int a, int b> edges;//cost로 오름차순 정렬된 간선 리스트
    // 부모테이블 초기화 (부모 = 자기자신)
    int parent[] = {1,2,3,...,V};
    
    // 신장 트리의 최소 비용을 반환하는 함수
    // parent를 따라가면 신장트리도 출력 가능
    int min_spanning(int[] parent) {
        for (int i=0; i<E; i++) {
            // 그래프의 간선 a,b
            int a = edges[i].a;
            int b = edges[i].b;
            int cost = edges[i].cost;
            //cycle이 발생하지 않으면 집합에 포함시킴
            if (find_parent(a) != find_parent(b)) {
                union_parent(a,b);
                result += cost;
        }
        return false;
    }
    ~~~

## 위상정렬 (Topology Sort)
: 방향그래프의 모든 노드를 '방향성에 거스르지 않도록 나열'하는 알고리즘  
ex. 선수과목을 고려한 학습 순서 결정
- 시간 복잡도  
    - O(V+E)
- 프로세스
    - 진입차수(indegree)테이블 사용
    1. 진입차수(indegree)가 0인 노드를 큐에 넣는다
    2. 큐가 빌 때까지 다음 과정을 반복한다
        1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다
        2. 새롭게 진입차수(indegree)가 0이 된 노드를 큐에 넣는다
    - 만약 모든 원소를 방문하기 전에 큐가 비면, 사이클이 존재하는 것
    - 답이 여러가지가 될 수 있음
- source code
    ~~~cpp
    // 노드와 간선의 개수
    int V,E;
    // 진입차수 테이블 초기화
    int indegree[V];
    while(E--) {
        //간선 정보 입력받음
        int a,b = input();
        graph[a].push_back(b);
        //진입차수 1증가
        indgree[b] += 1;
    }
    
    // result배열에 위상정렬 결과를 담는 함수
    vector<int> result;
    void min_spanning(int[] parent) {
        queue<int> q;
        //시작시 진입차수가 0인 노드 담기
        for (int i=1; i<=V; i++) {
            if (indgree[i] == 0)
                q.push(i);
        }

        //큐가 빌 때까지 반복
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            result.push_back(current);
            //current와 연결된 노드들의 진입차수 빼기
            for (auto e : graph[current]) {
                indgree[e] -= 1;
                if (indgree[e] == 0) {
                    q.push(e);
                }
            }
        }
    }
    ~~~